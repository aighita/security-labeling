# Security Labeling for Embedded Packages (AGL / Raspberry Pi)

This Python script performs an automated security analysis of software packages within an embedded platform (e.g., AGL on Raspberry Pi 4), combining local technical metadata with external data from GitHub and official OpenSSF criticality scores.

---

## 📌 Functionality

The script:

- Loads an Excel file containing metadata for the platform's packages.
- Normalizes technical indicators (CVE, static/dynamic analysis, code coverage) to a 0–10 scale.
- Automatically searches GitHub for each package's associated repository.
- Estimates package criticality based on GitHub stars.
- Generates a `criticality_input.yml` file containing the identified repositories.
- Runs `criticality_score` and injects official criticality scores where available.
- Computes final security scores per package.
- Generates charts and exports all results into a consolidated `.xlsx` file.

---

## 🧮 Security Score Formula

S = 0.30 × Criticality + 0.25 × CVE + 0.15 × Static Analysis + 0.15 × Dynamic Analysis + 0.15 × Code Coverage

All components are normalized to a 0–10 scale. The resulting S value is the overall package security score.

---

## 📁 Output Files

- `rezultate_eticheta_securitate.xlsx` – full scoring and aggregation:
  - **Detailed Scores** – per-package results
  - **Platform Aggregates** – average, min, max scores
  - **GitHub Stats** – search results, top/lowest starred repos
- `criticality_input.yml` – GitHub repository list for OpenSSF analysis
- `criticality_output.csv` – generated by `criticality_score`
- `distributie_scoruri_securitate.png` – histogram of security scores

---

## 🛠️ Requirements

- Python 3.8+
- Required libraries:
  - `pandas`
  - `matplotlib`
  - `requests`
  - `python-dotenv`

A personal GitHub token is required, configured in a `.env` file:

```
GIT_HUB_TOKEN=ghp_XXXXXXXXXXXXXXXXXXXX
```

---

## ▶️ How to Run

### 1. Install dependencies (recommended in a virtual environment)

```bash
python3 -m venv venv
source venv/bin/activate
pip install -r requirements
```

### 2. Clone and install `criticality_score` (first-time only)

```bash
git clone https://github.com/ossf/criticality_score.git
```

### 3. Run the main script

```bash
python3 script.py
```

---

## 📤 Criticality Evaluation via OpenSSF

The script will automatically generate `criticality_input.yml` and attempt to run:

```bash
python3 -m criticality_score.run \
  --input=criticality_input.yml \
  --github_token=... \
  --output_format=csv \
  --output=criticality_output.csv
```

If the automatic execution fails, you can run the command manually and then rerun the Python script to import real scores.

---

## 📈 Sample Output

```text
>> Searching GitHub for: bash
[MATCHED] 'bash' → bminor/bash (⭐ 736)
>> Running criticality_score...
>> Scores written to criticality_output.csv
>> OpenSSF criticality scores injected successfully.
>> File saved: rezultate_eticheta_securitate.xlsx
```

---

## 🔒 Notes

- If no official score is found, the script falls back to a GitHub star-based estimation.
- For transparency, both estimated and real scores can be compared in the Excel output.

---

## 📚 Resources

- [OpenSSF criticality_score](https://github.com/ossf/criticality_score)
- [GitHub REST API Docs](https://docs.github.com/en/rest)

---

## 🧑‍💻 Author

This script was developed as part of a university-level project on embedded system security assessment.